A program becomes a process when its loaded from the static memory _(HDD)_ to the memory _(RAM)_

# What is memory management?
Its the act of managing computer memory _(duh)_. It provides ways to allocate portion of memory to programs of their request and freeing it when no longer needed.

# Reminder
The memory is a linear array of bytes
![[Pasted image 20230302084514.png|400]]

An address space is the set of all possible memory addresses that a program or process can use to access memory in a computer system. In other words, it is the range of memory addresses that a program can reference when accessing data in memory.

Each program or process has its own unique address space, which is managed by the operating system. The operating system maps the address space of a program to a physical memory location using a process called address translation. This allows the program to access data stored in memory without needing to know the physical memory address where the data is actually located.

The address space is divided into segments or pages, which are used to store specific data such as program code, stack, and heap.
![[Pasted image 20230302084656.png|300]]

# Logical VS Physical address:
- `Physical:` A physical address is a memory address that directly corresponds to a physical location in memory. It is also known as a real address. The physical address refers to the actual location of the data in memory, which is typically represented as a binary number. Physical addresses are used by the [[#Dynamic Relocation|memory management unit (MMU)]] to access the physical memory.
- `Logical:` A logical address, also known as a virtual address, is an address that is generated by the CPU. Logical addresses are used to access memory from the perspective of a process or program. Logical addresses do not correspond directly to a physical location in memory, but rather they are translated by the [[#Dynamic Relocation|MMU]] into a physical address.

## Dynamic Relocation
`Memory Management Unit (MMU)` is the hardware device that converts `logical` to `physical` addresses based on the schema.
![[Pasted image 20230302090452.png]]

To be more exact, when MMU assigns a physical address in the RAM, it has to transform the logical address into the physical one
![[Pasted image 20230302163014.png]]

Each process has its own address space _([[#Base & Limit Registers]])_

A program cannot know during compilation where it will be allocated in memory.
Plus its location in physical can vary during implementation because of **swapping.**
![[Pasted image 20230302164624.png|400]]

## Base & Limit Registers
These are 2 registers that describe a partition in the memory. _(They protect the memory)_:
- `Base register:` gives starting address for process.
- `Limit register:` limits the offset accessible from the relocation register.
![[Pasted image 20230302165150.png|600]]


For every address generated, at runtime:
- Compare the end of the logical address to the limit register _(& abort if larger)_
- Add the end of the logical address to the base register to give physical memory address

_For example:_
Base register = 200
Limit register = 300
![[Pasted image 20230302163712.png|400]]

Then the physical address = 200 + 20 < 300

# Access Binding
Access binding is fixing physical address to logical address of a process address space.

Types of access binding:
- `Compile time binding:` if program location is fixed & known ahead of time, we identify the address during compilation.
- `Load time binding:` program location in memory is unknown until run-time and location is fixed
- `Execution time binding:` process can be moved in memory during execution.

# Loading a Process

## Memory management schemes
There was several schemes throughout history:
- `No memory abstraction:` Runs a single program at a time.
  The physical memory is allocated to the process from 0 to some maximum.
  Running several programs at the same time requires **swapping** from HDD to memory.
  ![[Pasted image 20230302085026.png|600]]
- `Memory abstraction (address space):` Processes shouldnt directly talk to memory. Each process has its own address space.
   During compilation, we give the process logical addresses from 0 to max.
   The physical address is base + logical address
   ![[Pasted image 20230302090032.png|500]]
    Each process has its base register & its limit register.
     The location of a process in memory can vary during implementation _(dynamic relocation)_



# Multiprogramming & Swapping
## Multiprogramming
Multiprogramming is many processing being executed in memory. When a program is running, the entire program must be in memory.
The memory is divided into partitions and each program is put into a single partition

## Swapping
Swapping occurs between processes to allow multiple programs to be executed at once

# Fragmentation
Consider the following image: _(Read from left to right and top to bottom)_
![[Pasted image 20230302165725.png]]

This is the physical memory, and we are adding processes to it one at a time. You can notice when we added P4 we [[#Swapping|swapped]] it with P2, leaving a small gap, same happens for P5. Now theres enough free space for P6 but its not compacted together.

This is called fragmentation where the free space in memory is scattered. Fragmentation causes degradation in performance and loss of space.

## Dealing With Fragmentation
`Compaction:` This method, from time to time, shifts processes around to collect all free space into one contiguous block
![[Pasted image 20230302170315.png|400]]

# Management Data Structure
Each chunk of memory is either used by some process or unused. And we need to keep track of whats free and whats not free.

For this we have 2 methods:

## Bit Maps
Bit maps are basically long strings of 0s _(free)_ and 1s _(used)_ where each bit represents a cell in memory.
![[Pasted image 20230302170759.png|600]]

## Linked Lists
_Reminder: [[ðŸŸ©2 @ Linked Lists]]_

Basically each element of the list has 4 values:
- Free / in-use Bit _(â€œP=process, H=holeâ€)_
- Starting address
- Length
- Pointer to next element

![[Pasted image 20230302171003.png|600]]

# Layout Schemes
There are 2 types of layouts:

## Continuous Layout Schemes
In this layout, the process is loaded entirely into the memory as a consecutive bunch.

But this layout has problems, such as:
- You cant execute a process bigger than the memory
- fragmentation
- Process expansion _(process size is not static)_

To reduce these problems we have another type of continuous layout, which is: 
Divide the memory into fixed partitions with different sizes, each associated with a queue.
![[Pasted image 20230302193822.png|600]]
_For example:_ all processes less than 50KB go to C

This method solves the problem of external fragmentation. But this causes internal fragmentation, where theres fragmentation within each partition.

### Algorithms for loading processes
In the following we will show algorithms for loading processes in a memory with no fixed partition. 
![[Pasted image 20230302194638.png]]

- `First Fit:` start from the beginning of the memory and load the process at the 1st free zone that is equal or greater than the size of the process 
- `Best Fit:` search the entire list from beginning to end and take the smallest hole thats adequate
- `Worst Fit:` search the entire list and take the largest hole thats adequate
- `Next Fit:` Similar to "First Fit" but continue from the last position of the last placed process without restarting from the beginning of the list

## Non-Continuous Layout Scheme
These schemes associate to each process an address space **equal to a max addressing size.**

_For example:_
```
If we're working on a 32 bit architecture. Then the process can grow in size up to 2^32 bits = 4GB (4GB is the size of max addrressing)
So we can have an address from 000...0(32 bits) to 111...1(32 bits)
```

### Paging
For this scheme we divide the process address space into equal and fixed chunks called **pages.**
The size of the page is a pre-determined configured during the installation of the system _(4KB on 32bit machines)_

**The size of the page must be a power of 2.** 
Then the number of pages is equal to:
$$\Large \color{green} Nb\space Pages = \frac{size(process)}{size(page)}$$
_For example:_
```
Suppose a process with a size of 16KB on a 32 bit (4KB page) system.
Then the nb of pages = 16/4 = 4 pages
```
![[Pasted image 20230303102705.png]]

The **`logical address`** is composed of: `(page number, offset inside the page)`
Where:
$$\Large \color{green} Page \space Number = \frac{address}{page \space size}$$
$$\Large \color{cyan} Offset = address \space \% \space page \space size$$
_For example:_
```
Say that the CPU makes access to address 200 bytes
Then to get:
Page number = address / page size = 200/4096 = 0
Offset = address % page size = 200 % 4096 = 200

And so we get the logical address : (0, 200)
```

### Frames 
Not only the logical memory is divided into pages, but also the **physical memory** is divided into fixed and equal chunks called **frames**.
**The size of a frame is equal to the size of a page.**

The **`physical address`** is composed of: `(frame number, offset inside the frame)`
![[Pasted image 20230303104029.png|600]]

### Loading the process into memory
In [[#Non-Continuous Layout Scheme]] the process is not entirely loaded into memory. Instead its loaded [[#Paging|page]] per page, however they're not required to be consecutive in memory.

To start from scratch, the OS decomposes the address space of the process to a set of pages. These pages are stored consecutively in the swap area.
![[Pasted image 20230303104617.png|600]]

Now during execution, the CPU makes access to the address _(for example 250 bytes, which makes gives us (page 0, offset 250))_. And then it loads the page that contains the address into the memory.
Then the [[#Dynamic Relocation|memory manager]] stores the loaded pages into one of the free frames.
![[Pasted image 20230303104946.png|600]]

### Translation from logical to physical
In translation from logical address _(page number, offset)_ to physical address _(frame number, offset)_, the **offset** is always the same because the page and frames are the same size. But the frame and page number might defer.

### Page Table
The page table is a data structure used by a virtual memory system to store the mapping between virtual address and physical address.
![[Pasted image 20230303130550.png|400]]
_For example:_
```
Suppose the CPU makes reference to the address 200 bytes (command: mv REG 200).
1. The MMU transforms it into a logical address: 0, 200.
2. The MMU checks the presence bit of 0. It is 0, then the page is not loaded yet to physical memory.
3. The MMU loads loads page 0 into memeory in any free frame
```

![[Screenshot_39.png|600]]
Each process has its own page table. 
The virtual address is split into page number _(higher order bits)_ and offset _(low level bits)_

The page table itself is stored in frame inside the memory. However it may be too big that itself might be decomposed into multiple pages and stored in multiple frames.
The address where its starts is placed in a special register. _(The MMU converts it to know where it is and use it)_

#### Page table structure
Each **page table entry _(PTE)_ is 32 bits** and has the following attributes:
- `presence / absence bit:`
	- `1` page is loaded in physical memory and can be used _(page hit)_
	- `0` page not loaded, still in swapping area _(page fault)_
- `protection bit:` The protection can be either 1 or 3 bits:
	- `1 bit:` 0 for read/write and 1 for read only.
	- `3 bits:` read-write-execute _(1 True, 0 False)_
- `Modified:` 
	- `dirty:` must be saved to disk before removed from physical memory
	- `clean:` can be directly removed from physical memory
- `Referenced:` tells how many times the frame was accessed.
- `Frame number:` number of the frame in physical memory where the page is loaded
![[Pasted image 20230303131711.png|600]]

### Multi-Level Paging
**The problem:**
>Each process has its own page table. And the page table must contain a number of rows equal to the max size of an address space. 
>This causes a problem, because say we have a 32 bit architecture and page size of 4KB, which means we have 2^20 different pages, and 2^20 PTE in the page table.
The OS will allocate for each process loaded into the memory a paging table consisting of 2^20 entries. Then the size of the paging table is 2^20 * 32 = 4MB of data just for the paging table **that is stored in the physical memory**.
This also means we need at least **1K frames** for storing the paging table of **one process**.

_For example:_
![[Screenshot_1a2.png|800]]

The point of multi-level paging is removing the entries that are not used and load them into the memory only when needed.

**This works by dividing the table and page part of the logical address into 2 parts:**
1. first level page _(external table)_
2. second level page _(internal table)_
![[Pasted image 20230303143225.png|400]]

The first table entries point to a page table that contains pages from x to y
![[Pasted image 20230303143535.png|600]]

In the 32 bit architecture, the Top-level page table has 1024 entries, i.e. 1024 2nd level tables with each 1024 entries, each of size 4MB
![[Screenshot_1a2.png|600]]

Here the virtual address space is divided into smaller blocks called _"page directories"_, each of which contains a list of page entries.
Multi-level paging allows the system to use a virtual address space larger than its physical memeory size, since not all of the virtual address needs to be stored in the main memory address at the same time.

_For example:_
```
Given 32 bit virtual address 00403004 (hex) = 4,206,596 (dec) converting to binary we have:
```
![[Screenshot_2.png|700]]
![[Screenshot_3.png|700]]
![[Screenshot_4.png|700]]