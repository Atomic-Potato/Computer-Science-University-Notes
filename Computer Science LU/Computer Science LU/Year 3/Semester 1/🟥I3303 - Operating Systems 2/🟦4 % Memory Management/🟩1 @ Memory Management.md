A program becomes a process when its loaded from the static memory _(HDD)_ to the memory _(RAM)_

# What is memory management?
Its the act of managing computer memory _(duh)_. It provides ways to allocate portion of memory to programs of their request and freeing it when no longer needed.

# Reminder
The memory is a linear array of bytes
![[Pasted image 20230302084514.png|400]]

The address space of a process is the set of addresses accessible by a process.
![[Pasted image 20230302084656.png|300]]

# Logical VS Physical address:
- `Physical:` A physical address is a memory address that directly corresponds to a physical location in memory. It is also known as a real address. The physical address refers to the actual location of the data in memory, which is typically represented as a binary number. Physical addresses are used by the [[#Dynamic Relocation|memory management unit (MMU)]] to access the physical memory.
- `Logical:` A logical address, also known as a virtual address, is an address that is generated by the CPU. Logical addresses are used to access memory from the perspective of a process or program. Logical addresses do not correspond directly to a physical location in memory, but rather they are translated by the [[#Dynamic Relocation|MMU]] into a physical address.

## Dynamic Relocation
`Memory Management Unit (MMU)` is the hardware device that converts `logical` to `physical` addresses based on the schema.
![[Pasted image 20230302090452.png]]

To be more exact, when MMU assigns a physical address in the RAM in has to transform the logical address into the physical one
![[Pasted image 20230302163014.png]]

Each process has its own address space _([[#Base & Limit Registers]])_

A program cannot know during compilation where it will be allocated in memory.
Plus its location in physical can vary during implementation because of **swapping.**
![[Pasted image 20230302164624.png|400]]

## Base & Limit Registers
These are 2 registers that describe a partition in the memory. _(They protect the memory)_:
- `Base register:` gives starting address for process.
- `Limit register:` limits the offset accessible from the relocation register.
![[Pasted image 20230302165150.png|600]]


For every address generated, at runtime:
- Compare the end of the logical address to the limit register _(& abort if larger)_
- Add the end of the logical address to the base register to give physical memory address

_For example:_
Base register = 200
Limit register = 300
![[Pasted image 20230302163712.png|400]]

Then the physical address = 200 + 20 < 300

# Access Binding
Access binding is fixing physical address to logical address of a processâ€™ address space.

Types of access binding:
- `Compile time binding:` if program location is fixed & known ahead of time, we identify the address during compilation.
- `Load time binding:` program location in memory is unknown until run-time and location is fixed
- `Execution time binding:` process can be moved in memory during execution.

# Loading a Process

## Memory management schemes
There was several schemes throughout history:
- `No memory abstraction:` Runs a single program at a time.
  The physical memory is allocated to the process from 0 to some maximum.
  Running several programs at the same time requires **swapping** from HDD to memory.
  ![[Pasted image 20230302085026.png|600]]
- `Memory abstraction (address space):` Processes shouldnt directly talk to memory. Each process has its own address space.
   During compilation, we give the process logical addresses from 0 to max.
   The physical address is base + logical address
   ![[Pasted image 20230302090032.png|500]]
    Each process has its base register & its limit register.
     The location of a process in memory can vary during implementation _(dynamic relocation)_



# Multiprogramming & Swapping
## Multiprogramming
Multiprogramming is many processing being executed in memory. When a program is running, the entire program must be in memory.
The memory is divided into partitions and each program is put into a single partition

## Swapping
Swapping occurs between processes to allow multiple programs to be executed at once

# Fragmentation
Consider the following image: _(Read from right to left and top to bottom)_
![[Pasted image 20230302165725.png]]

This is the physical memory, and we are adding processes to it one at a time. You can notice when we added P4 we [[#Swapping|swapped]] it with P2, leaving a small gap, same happens for P5. Now theres enough free space for P6 but its not compacted together.

This is called fragmentation where the free space in memory is scattered. Fragmentation causes degradation in performance and loss of space.

## Dealing With Fragmentation
`Compaction:` This method, from time to time, shifts processes around to collect all free space into one contiguous block
![[Pasted image 20230302170315.png|400]]

# Management Data Structure
Each chunk of memory is either used by some process or unused. And we need to keep track of whats free and whats not free.

For this we have 2 methods:

## Bit Maps
Bit maps are basically long strings of 0s _(free)_ and 1s _(used)_ where each bit represents a cell in memory.
![[Pasted image 20230302170759.png|600]]

## Linked Lists
_Reminder: [[ðŸŸ©2 @ Linked Lists]]_

Basically each element of the list has 4 values:
- Free / in-use Bit _(â€œP=process, H=holeâ€)_
- Starting address
- Length
- Pointer to next element

![[Pasted image 20230302171003.png|600]]

# Layout Schemes
There are 2 types of layouts:

## Continuous Layout:
In this layout, the process is loaded entirely into the memory as a consecutive bunch.

But this layout has problems, such as:
- You cant execute a process bigger than the memory
- fragmentation
- Process expansion _(process size is not static)_

To reduce these problems we have another type of continuous layout, which is: 
Divide the memory into fixed partitions with different sizes, each associated with a queue.
![[Pasted image 20230302193822.png|600]]
_For example:_ all processes less than 50KB go to C

This method solves the problem of external fragmentation. But this causes internal fragmentation, where theres fragmentation within each partition.

### Algorithms for loading processes
In the following we will show algorithms for loading processes in a memory with no fixed partition. 
![[Pasted image 20230302194638.png]]

- `First Fit:` start from the beginning of the memory and load the process at the 1st free zone that is equal or greater than the size of the process 
- `Best Fit:` search the entire list from beginning to end and take the smallest hole thats adequate
- `Worst Fit:` search the entire list and take the largest hole thats adequate
- `Next Fit:` Similar to "First Fit" but continue from the last position of the last placed process without restarting from the beginning of the list

