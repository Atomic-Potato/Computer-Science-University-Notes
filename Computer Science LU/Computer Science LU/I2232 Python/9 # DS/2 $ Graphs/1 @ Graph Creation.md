```python
import networkx as nx

# Creating a Graph
G = nx.Graph() # Right now G is empty

# Add a node
G.add_node(1)
G.add_nodes_from([2,3]) # You can also add a list of nodes by passing a list argument

# Add edges
G.add_edge(1,2)
e = (2,3)
G.add_edge(*e) # * unpacks the tuple
G.add_edges_from([(1,2), (1,3)]) # Just like nodes we can add edges from a list
```
In addition to constructing graphs node-by-node or edge-by-edge, they can also be generated by applying classic graph operations, such as:
* `subgraph(G, nbunch)`      - induced subgraph view of G on nodes in `nbunch`
* `union(G1,G2)`              - graph union
* `disjoint_union(G1,G2)`    - graph union assuming all nodes are different
* `cartesian_product(G1,G2)` - return Cartesian product graph
* `compose(G1,G2)`           - combine graphs identifying nodes common to both
* `complement(G)`            - graph complement
* `create_empty_copy(G)`     - return an empty copy of the same graph class
* `convert_to_undirected(G)` - return an undirected representation of G
* `convert_to_directed(G)`   - return a directed representation of G

Separate classes exist for different types of Graphs. For example the `nx.DiGraph()` class allows you to create a Directed Graph. Specific graphs containing paths can be created directly using a single method. For a full list of Graph creation methods please refer to the full documentation.